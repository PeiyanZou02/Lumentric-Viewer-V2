<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
  <title>Slit-Scan Pro (Fixed Color)</title>
  
  <style>
    /* =========================================
       CSS STYLES
       ========================================= */
    :root {
      --bg-color: #000000;
      --glass-bg: rgba(20, 20, 20, 0.85);
      --glass-border: rgba(255, 255, 255, 0.15);
      --accent: #0A84FF;
      --danger: #FF453A;
      --active: #FFD60A; 
      --text-main: #FFFFFF;
      --radius: 16px;
    }

    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; outline: none; user-select: none; }
    
    body {
      margin: 0; overflow: hidden; background: var(--bg-color);
      font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", Roboto, sans-serif;
      color: var(--text-main);
    }

    #mainCanvas {
      display: block; width: 100vw; height: 100vh; touch-action: none;
      position: absolute; top: 0; left: 0; z-index: 1;
    }

    .top-ui {
      position: absolute; top: env(safe-area-inset-top, 15px); 
      left: 15px; right: 15px;
      display: flex; justify-content: space-between; align-items: flex-start;
      z-index: 10; pointer-events: none;
    }

    .status-badge {
      font-size: 12px; font-weight: 600;
      background: rgba(0,0,0,0.6); backdrop-filter: blur(8px);
      padding: 6px 12px; border-radius: 20px;
      display: flex; align-items: center; gap: 8px;
      border: 1px solid var(--glass-border);
      height: 32px;
      pointer-events: auto;
    }
    .dot { width: 8px; height: 8px; background: #32D74B; border-radius: 50%; box-shadow: 0 0 5px #32D74B; }
    .dot.recording { background: var(--danger); animation: pulse 1s infinite; }
    .dot.gyro-active { background: var(--active); }
    .dot.buffered { background: #0A84FF; box-shadow: 0 0 5px #0A84FF; } 

    @keyframes pulse { 0% { opacity: 1; transform: scale(1); } 50% { opacity: 0.5; transform: scale(1.2); } 100% { opacity: 1; transform: scale(1); } }

    .right-ui-group {
      display: flex; flex-direction: column; align-items: flex-end; gap: 10px;
      pointer-events: auto;
    }

    .fab-group { display: flex; gap: 8px; }

    .fab {
      height: 40px; padding: 0 14px;
      background: rgba(255, 255, 255, 0.15);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 20px;
      display: flex; justify-content: center; align-items: center;
      font-size: 13px; font-weight: 600; cursor: pointer;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      color: var(--text-main);
      white-space: nowrap;
    }
    .fab:active { transform: scale(0.95); }
    
    .fab.paint-btn { background: var(--text-main); color: #000; }
    .fab.paint-btn.recording { background: var(--danger); color: #fff; border-color: var(--danger); }
    .fab.sensor-btn.active { background: var(--accent); color: #fff; border-color: var(--accent); }

    .lumetric-box {
      background: rgba(0, 0, 0, 0.7);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 8px;
      backdrop-filter: blur(4px);
      padding: 2px;
    }
    #waveformCanvas { width: 100px !important; height: 50px !important; display: block; }

    .control-sheet {
      position: absolute; bottom: 0; left: 0; right: 0;
      background: var(--glass-bg);
      backdrop-filter: blur(25px);
      border-radius: var(--radius) var(--radius) 0 0;
      border-top: 1px solid var(--glass-border);
      padding: 15px 20px calc(20px + env(safe-area-inset-bottom));
      z-index: 20;
      transition: transform 0.3s cubic-bezier(0.16, 1, 0.3, 1);
      max-height: 70vh; overflow-y: auto;
      transform: translateY(0);
    }
    .control-sheet.collapsed { transform: translateY(calc(100% - 40px)); }

    .sheet-handle-area {
      width: 100%; height: 30px; position: absolute; top: 0; left: 0;
      display: flex; justify-content: center; align-items: center;
      cursor: pointer; z-index: 30;
    }
    .sheet-handle { width: 40px; height: 5px; background: rgba(255,255,255,0.3); border-radius: 10px; }

    .actions-grid {
      display: grid; grid-template-columns: 1fr 1fr; gap: 10px;
      margin-top: 15px; margin-bottom: 20px;
    }

    .btn {
      background: rgba(255,255,255,0.12); border: none;
      color: var(--text-main); padding: 14px; border-radius: 10px;
      font-size: 13px; font-weight: 500; cursor: pointer; text-align: center;
    }
    .btn.primary { background: var(--text-main); color: #000; font-weight: 600; }
    .btn.accent { background: var(--accent); color: #fff; font-weight: 600; }

    .file-upload { position: relative; overflow: hidden; }
    .file-upload input { position: absolute; left: 0; top: 0; width: 100%; height: 100%; opacity: 0; }

    .slider-container { margin-bottom: 18px; }
    .slider-label {
      display: flex; justify-content: space-between;
      font-size: 12px; color: rgba(255,255,255,0.6); margin-bottom: 8px;
    }
    .slider-value { color: var(--text-main); font-weight: 600; font-family: monospace; }
    
    input[type=range] { -webkit-appearance: none; appearance: none; width: 100%; background: transparent; }
    input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 4px; background: rgba(255,255,255,0.2); border-radius: 2px; }
    input[type=range]::-webkit-slider-thumb {
      -webkit-appearance: none; appearance: none; height: 20px; width: 20px; border-radius: 50%;
      background: #fff; margin-top: -8px; box-shadow: 0 2px 8px rgba(0,0,0,0.5);
    }
    
    #toast {
      position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.9); color: white; padding: 10px 20px;
      border-radius: 30px; font-size: 13px; opacity: 0; pointer-events: none;
      transition: opacity 0.3s; z-index: 100; backdrop-filter: blur(10px);
      border: 1px solid rgba(255,255,255,0.1);
      text-align: center; white-space: nowrap;
    }
  </style>
</head>
<body>

  <div id="toast">Ready</div>

  <div class="top-ui">
    <div class="status-badge" id="statusBadge">
      <span class="dot" id="statusDot"></span>
      <span id="sourceText">Ready</span>
    </div>
    
    <div class="right-ui-group">
      <div class="fab-group">
        <div class="fab" id="clearFab" title="Clear All">üóëÔ∏è</div>
        <div class="fab sensor-btn" id="sensorFab">üß≠ Gyro</div>
        <div class="fab paint-btn" id="paintFab">‚óè REC</div>
      </div>
      <div class="lumetric-box">
        <canvas id="waveformCanvas" width="200" height="100"></canvas>
      </div>
    </div>
  </div>

  <div class="control-sheet" id="controlSheet">
    <div class="sheet-handle-area" id="sheetToggle">
      <div class="sheet-handle"></div>
    </div>

    <div class="actions-grid">
      <button class="btn accent" id="exportBtn">Export All</button>
      <button class="btn" id="camResetBtn">Reset Camera</button>
      <div class="btn file-upload">
        Import Img
        <input type="file" id="imageInput" accept="image/*">
      </div>
      <button class="btn primary" id="toggleModeBtn">View Points</button>
    </div>

    <div class="slider-container">
      <div class="slider-label"><span>Extrusion Depth (Z)</span><span class="slider-value" id="extrusionVal">300</span></div>
      <input type="range" id="extrusionSlider" min="0" max="800" value="300">
    </div>

    <div class="slider-container">
      <div class="slider-label"><span>Forward Speed</span><span class="slider-value" id="speedVal">15</span></div>
      <input type="range" id="speedSlider" min="0" max="60" value="15" step="1">
    </div>

    <div class="slider-container">
      <div class="slider-label"><span>Point Size</span><span class="slider-value" id="pointSizeVal">2.0</span></div>
      <input type="range" id="pointSizeSlider" min="1" max="10" value="2" step="0.5">
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/utils/BufferGeometryUtils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/PLYExporter.js"></script>

  <script>
    const CONFIG = {
      baseW: 320, 
      baseH: 240,
      bgColor: 0x050505
    };

    let scene, camera, renderer, controls;
    let video, imgEl;
    let geometryParticles, geometryMesh, pointsObj, meshObj;
    let particlesMat, meshMat;
    let worldGroup, cursorGroup;
    
    // Video Buffers
    let recorderCanvas = null;
    let chunksCanvas = [];
    let recorderWebcam = null;
    let chunksWebcam = [];
    
    // Downloadable Blobs
    let blobCanvasVideo = null;
    let blobWebcamVideo = null;
    
    let state = {
      mode: 'mesh', 
      source: 'camera', 
      extrusion: 300,
      pointSize: 2,
      resScale: 1,
      imageLoaded: false,
      planeW: 0,
      planeH: 0,
      isRecording: false,
      isGyroEnabled: false,
      scanSpeed: 15,
      lastPaintTime: 0
    };

    let deviceOrientation = { alpha: 0, beta: 0, gamma: 0 };
    let initialOffset = null;

    const offCanvas = document.createElement('canvas');
    const offCtx = offCanvas.getContext('2d', { willReadFrequently: true });
    
    const els = {
      sheet: document.getElementById('controlSheet'),
      sheetToggle: document.getElementById('sheetToggle'),
      paintFab: document.getElementById('paintFab'),
      clearFab: document.getElementById('clearFab'),
      sensorFab: document.getElementById('sensorFab'),
      modeBtn: document.getElementById('toggleModeBtn'),
      exportBtn: document.getElementById('exportBtn'),
      camResetBtn: document.getElementById('camResetBtn'),
      imgInput: document.getElementById('imageInput'),
      sliders: {
        ext: document.getElementById('extrusionSlider'),
        size: document.getElementById('pointSizeSlider'),
        speed: document.getElementById('speedSlider')
      },
      vals: {
        ext: document.getElementById('extrusionVal'),
        size: document.getElementById('pointSizeVal'),
        speed: document.getElementById('speedVal')
      },
      statusDot: document.getElementById('statusDot'),
      sourceText: document.getElementById('sourceText'),
      waveform: document.getElementById('waveformCanvas').getContext('2d'),
      toast: document.getElementById('toast')
    };

    init();
    animate();

    function init() {
      if (location.protocol !== 'https:' && location.hostname !== 'localhost' && location.hostname !== '127.0.0.1') {
         alert("Camera requires HTTPS.");
      }

      scene = new THREE.Scene();
      scene.background = new THREE.Color(CONFIG.bgColor);

      camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 20000);
      camera.position.set(0, 0, 600);

      renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.domElement.id = 'mainCanvas';
      document.body.appendChild(renderer.domElement);

      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.enablePan = false;
      
      worldGroup = new THREE.Group(); 
      scene.add(worldGroup);
      
      cursorGroup = new THREE.Group(); 
      scene.add(cursorGroup);

      particlesMat = new THREE.PointsMaterial({ size: state.pointSize, vertexColors: true });
      meshMat = new THREE.MeshPhongMaterial({ 
        vertexColors: true, side: THREE.DoubleSide, 
        shininess: 30, flatShading: true 
      });

      scene.add(new THREE.AmbientLight(0xffffff, 0.5));
      const dirLight = new THREE.DirectionalLight(0xffffff, 1);
      dirLight.position.set(0, 500, 500);
      scene.add(dirLight);

      resizeGrid(CONFIG.baseW, CONFIG.baseH);
      
      video = document.createElement('video');
      video.autoplay = true; video.muted = true; video.playsInline = true; 

      setupImageLoader();
      setupUI();
      startCamera();
      
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    }

    function resizeGrid(w, h) {
      if(w < 2 || h < 2) return; 

      while(cursorGroup.children.length > 0){ 
        const c = cursorGroup.children[0];
        cursorGroup.remove(c);
        if(c.geometry) c.geometry.dispose();
      }

      state.planeW = Math.floor(w);
      state.planeH = Math.floor(h);

      offCanvas.width = state.planeW;
      offCanvas.height = state.planeH;

      const count = state.planeW * state.planeH;

      geometryParticles = new THREE.BufferGeometry();
      const pos = new Float32Array(count * 3);
      const col = new Float32Array(count * 3);
      
      for(let i=0; i<count; i++) {
        const x = i % state.planeW;
        const y = Math.floor(i / state.planeW);
        pos[i*3] = x - state.planeW/2;       
        pos[i*3+1] = (state.planeH/2) - y;   
        pos[i*3+2] = 0;
      }
      
      geometryParticles.setAttribute('position', new THREE.BufferAttribute(pos, 3));
      geometryParticles.setAttribute('color', new THREE.BufferAttribute(col, 3));
      pointsObj = new THREE.Points(geometryParticles, particlesMat);
      
      geometryMesh = new THREE.PlaneBufferGeometry(state.planeW, state.planeH, state.planeW - 1, state.planeH - 1);
      const meshCount = geometryMesh.attributes.position.count;
      geometryMesh.setAttribute('color', new THREE.BufferAttribute(new Float32Array(meshCount * 3), 3));
      meshObj = new THREE.Mesh(geometryMesh, meshMat);

      updateVisibility();
    }

    function updateVisibility() {
      cursorGroup.remove(pointsObj);
      cursorGroup.remove(meshObj);
      if (state.mode === 'points') cursorGroup.add(pointsObj);
      else cursorGroup.add(meshObj);
    }

    function enableSensor() {
      if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
        DeviceOrientationEvent.requestPermission()
          .then(response => {
            if (response === 'granted') {
              window.addEventListener('deviceorientation', handleOrientation);
              activateSensorUI();
            } else { showToast("Permission Denied"); }
          }).catch(console.error);
      } else {
        window.addEventListener('deviceorientation', handleOrientation);
        activateSensorUI();
      }
    }

    function activateSensorUI() {
      state.isGyroEnabled = true;
      els.sensorFab.classList.add('active');
      els.statusDot.classList.add('gyro-active');
      showToast("Gyro Active");
      initialOffset = null; 
    }

    function handleOrientation(event) {
      if (!state.isGyroEnabled) return;
      const alpha = event.alpha ? THREE.MathUtils.degToRad(event.alpha) : 0;
      const beta = event.beta ? THREE.MathUtils.degToRad(event.beta) : 0;
      const gamma = event.gamma ? THREE.MathUtils.degToRad(event.gamma) : 0;

      if (!initialOffset) initialOffset = { alpha, beta, gamma };

      const euler = new THREE.Euler(beta - initialOffset.beta, alpha - initialOffset.alpha, -gamma + initialOffset.gamma, 'YXZ');
      cursorGroup.setRotationFromEuler(euler);
    }

    async function startCamera() {
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) return;
      if (video.srcObject) video.srcObject.getTracks().forEach(track => track.stop());

      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: false, video: { facingMode: "environment" } });
        video.srcObject = stream;
        video.play();
        state.source = 'camera';
        updateStatus("Ready");
      } catch (err) {
        showToast("Camera Error: " + err.message);
      }
    }

    function setupImageLoader() {
      imgEl = new Image();
      imgEl.crossOrigin = "Anonymous"; 
      imgEl.onload = () => {
        state.imageLoaded = true;
        state.source = 'image';
        applyImageResolution();
      };
    }

    function applyImageResolution() {
      if (!state.imageLoaded) return;
      const aspect = imgEl.naturalWidth / imgEl.naturalHeight;
      const h = CONFIG.baseH * state.resScale;
      const w = aspect >= 1 ? Math.round(h * aspect) : h; 
      resizeGrid(aspect >= 1 ? w : Math.round(h * aspect), h); 
    }

    function animate() {
      requestAnimationFrame(animate);
      if(updateTexture()) {
        processGeometry();
        if (state.isRecording) paintFrame();
        if (renderer.info.render.frame % 3 === 0) drawLumetric();
      }
      controls.update();
      renderer.render(scene, camera);
    }

    function updateTexture() {
      if (state.source === 'camera') {
        if (!video || video.readyState < 2 || video.videoWidth === 0) return false;
        const vw = video.videoWidth, vh = video.videoHeight;
        const cw = state.planeW, ch = state.planeH;
        const scale = Math.max(cw/vw, ch/vh);
        const dw = vw * scale, dh = vh * scale;
        offCtx.drawImage(video, (cw - dw)/2, (ch - dh)/2, dw, dh);
      } else {
        if (!state.imageLoaded) return false;
        offCtx.drawImage(imgEl, 0, 0, state.planeW, state.planeH);
      }
      return true;
    }

    function processGeometry() {
      const imgData = offCtx.getImageData(0, 0, state.planeW, state.planeH).data;
      const activeGeo = state.mode === 'points' ? geometryParticles : geometryMesh;
      if(!activeGeo) return;
      
      const posAttr = activeGeo.attributes.position;
      const colAttr = activeGeo.attributes.color;
      const count = posAttr.count;
      const extr = state.extrusion;

      for (let i = 0; i < count; i++) {
        const ptr = i * 4;
        const r = imgData[ptr], g = imgData[ptr+1], b = imgData[ptr+2];
        const lum = (0.299*r + 0.587*g + 0.114*b) / 255;
        
        posAttr.array[i*3+2] = lum * extr;
        colAttr.array[i*3] = r/255; 
        colAttr.array[i*3+1] = g/255; 
        colAttr.array[i*3+2] = b/255;
      }
      
      posAttr.needsUpdate = true;
      colAttr.needsUpdate = true;
      if (state.mode === 'mesh') {
        activeGeo.computeVertexNormals();
        activeGeo.attributes.normal.needsUpdate = true;
      }
    }

    function paintFrame() {
      const now = Date.now();
      if (now - state.lastPaintTime < 40) return; 
      state.lastPaintTime = now;

      let newObj;
      const srcObj = state.mode === 'points' ? pointsObj : meshObj;
      
      if (state.mode === 'points') {
        newObj = new THREE.Points(srcObj.geometry.clone(), particlesMat.clone());
      } else {
        newObj = new THREE.Mesh(srcObj.geometry.clone(), meshMat.clone());
      }

      newObj.rotation.copy(cursorGroup.rotation);
      newObj.position.copy(cursorGroup.position);
      worldGroup.add(newObj);

      const speed = state.scanSpeed;
      worldGroup.children.forEach(child => {
        child.position.z -= speed;
      });

      if (worldGroup.children.length > 80) {
        const old = worldGroup.children.shift();
        if(old.geometry) old.geometry.dispose();
        worldGroup.remove(old);
      }
    }

    // --- DUAL Recording (Buffered) ---
    function startDualRecording() {
      chunksCanvas = [];
      chunksWebcam = [];
      blobCanvasVideo = null;
      blobWebcamVideo = null;
      
      try {
        const streamCanvas = renderer.domElement.captureStream(30);
        recorderCanvas = new MediaRecorder(streamCanvas, { mimeType: 'video/webm' }); 
        recorderCanvas.ondataavailable = e => { if (e.data.size > 0) chunksCanvas.push(e.data); };
        recorderCanvas.onstop = () => {
            blobCanvasVideo = new Blob(chunksCanvas, { type: 'video/webm' });
            checkBufferStatus();
        };
        recorderCanvas.start();
      } catch(e) { console.error("Canvas Rec Error", e); }

      try {
        if (video.srcObject) {
          const streamWebcam = video.srcObject;
          recorderWebcam = new MediaRecorder(streamWebcam, { mimeType: 'video/webm' });
          recorderWebcam.ondataavailable = e => { if (e.data.size > 0) chunksWebcam.push(e.data); };
          recorderWebcam.onstop = () => {
              blobWebcamVideo = new Blob(chunksWebcam, { type: 'video/webm' });
              checkBufferStatus();
          };
          recorderWebcam.start();
        }
      } catch(e) { console.error("Webcam Rec Error", e); }
      
      showToast("Recording...");
    }

    function stopDualRecording() {
      if (recorderCanvas && recorderCanvas.state !== 'inactive') recorderCanvas.stop();
      if (recorderWebcam && recorderWebcam.state !== 'inactive') recorderWebcam.stop();
      showToast("Processing Videos...");
    }

    function checkBufferStatus() {
        if ((blobCanvasVideo || !recorderCanvas) && (blobWebcamVideo || !recorderWebcam)) {
            els.statusDot.className = "dot buffered";
            els.sourceText.innerText = "Captured";
            showToast("Videos Buffered. Ready to Export.");
        }
    }

    // --- Unified Export (The Big One) ---
    function performFullExport() {
      showToast("Packaging Export...");
      
      setTimeout(() => {
        try {
          const timestamp = Date.now();
          
          // 1. Download Videos (if exist in buffer)
          if (blobCanvasVideo) {
             downloadBlob(blobCanvasVideo, `scan_render_${timestamp}.webm`);
          }
          if (blobWebcamVideo) {
             setTimeout(() => downloadBlob(blobWebcamVideo, `scan_webcam_${timestamp}.webm`), 1000);
          }

          // 2. Process 3D Geometry
          const allMeshes = [...worldGroup.children];
          if(state.mode === 'points') allMeshes.push(pointsObj);
          else allMeshes.push(meshObj);

          let geometries = [];
          allMeshes.forEach(obj => {
            if (!obj.visible) return;
            const g = obj.geometry.clone();
            obj.updateMatrixWorld();
            g.applyMatrix4(obj.matrixWorld);
            // Ensure Color
            if (!g.attributes.color) {
               const count = g.attributes.position.count;
               const colors = new Float32Array(count * 3).fill(1); 
               g.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            }
            geometries.push(g);
          });

          if(geometries.length === 0) { 
              if(!blobCanvasVideo) showToast("Nothing to export"); 
              return; 
          }
          
          const merged = THREE.BufferGeometryUtils.mergeBufferGeometries(geometries);

          setTimeout(() => {
              if(state.mode === 'points') {
                 // --- PTS FORMAT EXPORT (Corrected with Colors) ---
                 const pos = merged.attributes.position.array;
                 const col = merged.attributes.color.array;
                 const count = merged.attributes.position.count;
                 
                 // Standard PTS: Header first (point count)
                 let ptsOutput = count + "\n";
                 
                 // Columns: X Y Z Intensity R G B
                 for (let i = 0; i < count; i++) {
                    const x = pos[i*3];
                    const y = pos[i*3+1];
                    const z = pos[i*3+2];
                    
                    const r = Math.floor(col[i*3] * 255);
                    const g = Math.floor(col[i*3+1] * 255);
                    const b = Math.floor(col[i*3+2] * 255);
                    
                    // Simple Intensity (Luminance)
                    const intensity = Math.floor(0.299*r + 0.587*g + 0.114*b);

                    if (!isNaN(x)) {
                        // Standard PTS Format: X Y Z Intensity R G B
                        ptsOutput += `${x.toFixed(4)} ${y.toFixed(4)} ${z.toFixed(4)} ${intensity} ${r} ${g} ${b}\n`;
                    }
                 }
                 
                 const blob = new Blob([ptsOutput], { type: 'text/plain' });
                 downloadBlob(blob, `scan_points_${timestamp}.pts`);
                 
              } else {
                 // PLY Export
                 const exporter = new THREE.PLYExporter();
                 const m = new THREE.Mesh(merged, meshMat);
                 exporter.parse(m, res => downloadBlob(new Blob([res]), `scan_mesh_${timestamp}.ply`), { binary: true });
              }
              
              merged.dispose();
              geometries.forEach(g => g.dispose());
              showToast("Export Complete");
              
          }, 2000); // Delay for 3D export

        } catch(e) { console.error(e); showToast("Export Error: " + e.message); }
      }, 100);
    }

    function downloadBlob(blob, name) {
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = name;
      a.style.display = 'none';
      document.body.appendChild(a);
      a.click();
      setTimeout(() => {
          document.body.removeChild(a);
          URL.revokeObjectURL(a.href);
      }, 2000);
    }

    // --- UI Actions ---
    function setupUI() {
      const toggleMenu = () => els.sheet.classList.toggle('collapsed');
      els.sheetToggle.addEventListener('click', (e) => { e.stopPropagation(); toggleMenu(); });
      renderer.domElement.addEventListener('click', () => els.sheet.classList.add('collapsed'));

      els.sensorFab.addEventListener('click', () => {
        if (!state.isGyroEnabled) enableSensor();
        else { showToast("Recalibrated"); initialOffset = null; }
      });

      // Recording
      els.paintFab.addEventListener('click', () => {
        state.isRecording = !state.isRecording;
        if(state.isRecording) {
          state.isPainting = true;
          startDualRecording();
          
          els.paintFab.classList.add('paint-btn', 'recording');
          els.paintFab.innerText = "üõë STOP";
          els.statusDot.className = "dot recording";
          els.sourceText.innerText = "Recording...";
        } else {
          state.isPainting = false;
          stopDualRecording(); // Only buffers, no download
          
          els.paintFab.classList.remove('paint-btn', 'recording');
          els.paintFab.innerText = "‚óè REC";
        }
      });

      els.clearFab.addEventListener('click', () => {
        while(worldGroup.children.length > 0){ 
          const c = worldGroup.children[0];
          worldGroup.remove(c); c.geometry.dispose();
        }
        // Clear buffers
        blobCanvasVideo = null;
        blobWebcamVideo = null;
        els.statusDot.className = "dot";
        els.sourceText.innerText = "Ready";
        showToast("Cleared All");
      });

      els.camResetBtn.addEventListener('click', startCamera);

      els.modeBtn.addEventListener('click', () => {
        state.mode = state.mode === 'mesh' ? 'points' : 'mesh';
        els.modeBtn.innerText = state.mode === 'mesh' ? 'View Points' : 'View Mesh';
        updateVisibility();
      });

      els.sliders.ext.addEventListener('input', (e) => { state.extrusion = e.target.value; els.vals.ext.innerText = e.target.value; });
      els.sliders.speed.addEventListener('input', (e) => { state.scanSpeed = e.target.value; els.vals.speed.innerText = e.target.value; });
      els.sliders.size.addEventListener('input', (e) => { state.pointSize = e.target.value; particlesMat.size = e.target.value; els.vals.size.innerText = parseFloat(e.target.value).toFixed(1); });
      
      // Export All
      els.exportBtn.addEventListener('click', performFullExport);
    }

    function updateStatus(text) { els.sourceText.innerText = text; }
    function showToast(msg) { els.toast.innerText = msg; els.toast.style.opacity = 1; setTimeout(() => els.toast.style.opacity = 0, 3000); }

    function drawLumetric() {
      const ctx = els.waveform;
      const w = ctx.canvas.width, h = ctx.canvas.height;
      ctx.fillStyle = 'rgba(0,0,0,1)'; ctx.fillRect(0,0,w,h);
      const data = offCtx.getImageData(0,0,state.planeW,state.planeH).data;
      ctx.fillStyle = state.isRecording ? '#FF453A' : (state.isGyroEnabled ? '#FFD60A' : '#0A84FF');
      for(let x=0; x<w; x++) {
        const srcX = Math.floor(x*(state.planeW/w));
        for(let y=0; y<state.planeH; y+=20) {
           const i = (y*state.planeW+srcX)*4;
           if(i<data.length) {
             const l = (0.299*data[i]+0.587*data[i+1]+0.114*data[i+2])/255;
             ctx.fillRect(x, h-(l*h), 1, 1.5);
           }
        }
      }
    }
  </script>
</body>
</html>
