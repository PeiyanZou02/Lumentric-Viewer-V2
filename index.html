<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
  <title>Gyro Slit-Scan</title>
  
  <style>
    /* =========================================
       CSS STYLES
       ========================================= */
    :root {
      --bg-color: #000000;
      --glass-bg: rgba(20, 20, 20, 0.85);
      --glass-border: rgba(255, 255, 255, 0.15);
      --accent: #0A84FF;
      --danger: #FF453A;
      --active: #FFD60A; 
      --text-main: #FFFFFF;
      --radius: 16px;
    }

    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; outline: none; user-select: none; }
    
    body {
      margin: 0; overflow: hidden; background: var(--bg-color);
      font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", Roboto, sans-serif;
      color: var(--text-main);
    }

    #mainCanvas {
      display: block; width: 100vw; height: 100vh; touch-action: none;
      position: absolute; top: 0; left: 0; z-index: 1;
    }

    /* Top UI */
    .top-ui {
      position: absolute; top: env(safe-area-inset-top, 15px); 
      left: 15px; right: 15px;
      display: flex; justify-content: space-between; align-items: flex-start;
      z-index: 10; pointer-events: none;
    }

    .status-badge {
      font-size: 12px; font-weight: 600;
      background: rgba(0,0,0,0.6); backdrop-filter: blur(8px);
      padding: 6px 12px; border-radius: 20px;
      display: flex; align-items: center; gap: 8px;
      border: 1px solid var(--glass-border);
      height: 32px;
      pointer-events: auto;
    }
    .dot { width: 6px; height: 6px; background: #32D74B; border-radius: 50%; box-shadow: 0 0 5px #32D74B; }
    .dot.recording { background: var(--danger); animation: pulse 1s infinite; }
    .dot.gyro-active { background: var(--active); }

    @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }

    .right-ui-group {
      display: flex; flex-direction: column; align-items: flex-end; gap: 10px;
      pointer-events: auto;
    }

    .fab-group { display: flex; gap: 8px; }

    .fab {
      height: 40px; padding: 0 14px;
      background: rgba(255, 255, 255, 0.15);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 20px;
      display: flex; justify-content: center; align-items: center;
      font-size: 13px; font-weight: 600; cursor: pointer;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      color: var(--text-main);
    }
    .fab:active { transform: scale(0.95); }
    
    .fab.paint-btn { background: var(--active); color: #000; border-color: var(--active); }
    .fab.sensor-btn.active { background: var(--accent); color: #fff; border-color: var(--accent); }

    .lumetric-box {
      background: rgba(0, 0, 0, 0.7);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 8px;
      backdrop-filter: blur(4px);
      padding: 2px;
    }
    #waveformCanvas { width: 100px !important; height: 50px !important; display: block; }

    /* Bottom Sheet */
    .control-sheet {
      position: absolute; bottom: 0; left: 0; right: 0;
      background: var(--glass-bg);
      backdrop-filter: blur(25px);
      border-radius: var(--radius) var(--radius) 0 0;
      border-top: 1px solid var(--glass-border);
      padding: 15px 20px calc(20px + env(safe-area-inset-bottom));
      z-index: 20;
      transition: transform 0.3s cubic-bezier(0.16, 1, 0.3, 1);
      max-height: 70vh; overflow-y: auto;
      transform: translateY(0);
    }
    .control-sheet.collapsed { transform: translateY(calc(100% - 40px)); }

    .sheet-handle-area {
      width: 100%; height: 30px; position: absolute; top: 0; left: 0;
      display: flex; justify-content: center; align-items: center;
      cursor: pointer; z-index: 30;
    }
    .sheet-handle { width: 40px; height: 5px; background: rgba(255,255,255,0.3); border-radius: 10px; }

    .actions-grid {
      display: grid; grid-template-columns: 1fr 1fr; gap: 10px;
      margin-top: 15px; margin-bottom: 20px;
    }

    .btn {
      background: rgba(255,255,255,0.12); border: none;
      color: var(--text-main); padding: 14px; border-radius: 10px;
      font-size: 13px; font-weight: 500; cursor: pointer; text-align: center;
    }
    .btn.primary { background: var(--text-main); color: #000; font-weight: 600; }
    .btn.accent { background: var(--accent); color: #fff; font-weight: 600; }

    .file-upload { position: relative; overflow: hidden; }
    .file-upload input { position: absolute; left: 0; top: 0; width: 100%; height: 100%; opacity: 0; }

    .slider-container { margin-bottom: 18px; }
    .slider-label {
      display: flex; justify-content: space-between;
      font-size: 12px; color: rgba(255,255,255,0.6); margin-bottom: 8px;
    }
    .slider-value { color: var(--text-main); font-weight: 600; font-family: monospace; }
    
    input[type=range] { -webkit-appearance: none; appearance: none; width: 100%; background: transparent; }
    input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 4px; background: rgba(255,255,255,0.2); border-radius: 2px; }
    input[type=range]::-webkit-slider-thumb {
      -webkit-appearance: none; appearance: none; height: 20px; width: 20px; border-radius: 50%;
      background: #fff; margin-top: -8px; box-shadow: 0 2px 8px rgba(0,0,0,0.5);
    }
    
    #toast {
      position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.9); color: white; padding: 12px 24px;
      border-radius: 30px; font-size: 13px; opacity: 0; pointer-events: none;
      transition: opacity 0.3s; z-index: 100; backdrop-filter: blur(10px);
      border: 1px solid rgba(255,255,255,0.1);
      text-align: center; white-space: nowrap;
    }
  </style>
</head>
<body>

  <div id="toast">Ready</div>

  <div class="top-ui">
    <div class="status-badge" id="statusBadge">
      <span class="dot" id="statusDot"></span>
      <span id="sourceText">Ready</span>
    </div>
    
    <div class="right-ui-group">
      <div class="fab-group">
        <div class="fab" id="clearFab" title="Clear All">üóëÔ∏è</div>
        <div class="fab sensor-btn" id="sensorFab">üß≠ Gyro</div>
        <div class="fab" id="paintFab">üñåÔ∏è REC</div>
      </div>
      <div class="lumetric-box">
        <canvas id="waveformCanvas" width="200" height="100"></canvas>
      </div>
    </div>
  </div>

  <div class="control-sheet" id="controlSheet">
    <div class="sheet-handle-area" id="sheetToggle">
      <div class="sheet-handle"></div>
    </div>

    <div class="actions-grid">
      <button class="btn primary" id="toggleModeBtn">View Points</button>
      <button class="btn accent" id="exportBtn">Export Scan</button>
      <button class="btn" id="camResetBtn">Reset Cam</button>
      <div class="btn file-upload">
        Import Img
        <input type="file" id="imageInput" accept="image/*">
      </div>
    </div>

    <div class="slider-container">
      <div class="slider-label"><span>Extrusion Depth (Z)</span><span class="slider-value" id="extrusionVal">300</span></div>
      <input type="range" id="extrusionSlider" min="0" max="800" value="300">
    </div>

    <div class="slider-container">
      <div class="slider-label"><span>Forward Speed (Simulated)</span><span class="slider-value" id="speedVal">15</span></div>
      <input type="range" id="speedSlider" min="0" max="60" value="15" step="1">
    </div>

    <div class="slider-container">
      <div class="slider-label"><span>Point Size</span><span class="slider-value" id="pointSizeVal">2.0</span></div>
      <input type="range" id="pointSizeSlider" min="1" max="10" value="2" step="0.5">
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/utils/BufferGeometryUtils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/PLYExporter.js"></script>

  <script>
    const CONFIG = {
      baseW: 320, 
      baseH: 240,
      bgColor: 0x050505
    };

    let scene, camera, renderer, controls;
    let video, imgEl;
    let geometryParticles, geometryMesh, pointsObj, meshObj;
    let particlesMat, meshMat;
    let worldGroup, cursorGroup; // ‰∏ñÁïåÁªÑ Âíå ÂΩìÂâçÂÖâÊ†áÁªÑ
    
    let state = {
      mode: 'mesh', 
      source: 'camera', 
      extrusion: 300,
      pointSize: 2,
      resScale: 1,
      imageLoaded: false,
      planeW: 0,
      planeH: 0,
      isPainting: false,
      isGyroEnabled: false,
      scanSpeed: 15,
      lastPaintTime: 0
    };

    // ‰º†ÊÑüÂô®Êï∞ÊçÆ
    let deviceOrientation = { alpha: 0, beta: 0, gamma: 0 };
    let initialOffset = null;

    const offCanvas = document.createElement('canvas');
    const offCtx = offCanvas.getContext('2d', { willReadFrequently: true });
    
    const els = {
      sheet: document.getElementById('controlSheet'),
      sheetToggle: document.getElementById('sheetToggle'),
      paintFab: document.getElementById('paintFab'),
      clearFab: document.getElementById('clearFab'),
      sensorFab: document.getElementById('sensorFab'),
      modeBtn: document.getElementById('toggleModeBtn'),
      exportBtn: document.getElementById('exportBtn'),
      camResetBtn: document.getElementById('camResetBtn'),
      imgInput: document.getElementById('imageInput'),
      sliders: {
        ext: document.getElementById('extrusionSlider'),
        size: document.getElementById('pointSizeSlider'),
        speed: document.getElementById('speedSlider')
      },
      vals: {
        ext: document.getElementById('extrusionVal'),
        size: document.getElementById('pointSizeVal'),
        speed: document.getElementById('speedVal')
      },
      statusDot: document.getElementById('statusDot'),
      sourceText: document.getElementById('sourceText'),
      waveform: document.getElementById('waveformCanvas').getContext('2d'),
      toast: document.getElementById('toast')
    };

    init();
    animate();

    function init() {
      // Scene Setup
      scene = new THREE.Scene();
      scene.background = new THREE.Color(CONFIG.bgColor);

      camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 20000);
      camera.position.set(0, 0, 600);

      renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.domElement.id = 'mainCanvas';
      document.body.appendChild(renderer.domElement);

      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.enablePan = false;
      
      // Groups
      worldGroup = new THREE.Group(); // Â≠òÊîæÁîªÂá∫Êù•ÁöÑ‰∏úË•ø
      scene.add(worldGroup);
      
      cursorGroup = new THREE.Group(); // Â≠òÊîæÂΩìÂâçÁöÑÂÆûÊó∂È¢ÑËßà
      scene.add(cursorGroup);

      // Materials
      particlesMat = new THREE.PointsMaterial({ size: state.pointSize, vertexColors: true });
      meshMat = new THREE.MeshPhongMaterial({ 
        vertexColors: true, side: THREE.DoubleSide, 
        shininess: 30, flatShading: true 
      });

      scene.add(new THREE.AmbientLight(0xffffff, 0.5));
      const dirLight = new THREE.DirectionalLight(0xffffff, 1);
      dirLight.position.set(0, 500, 500);
      scene.add(dirLight);

      resizeGrid(CONFIG.baseW, CONFIG.baseH);
      
      video = document.createElement('video');
      video.autoplay = true; video.muted = true; video.playsInline = true; 

      setupImageLoader();
      setupUI();
      startCamera();
      
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    }

    // ÂàùÂßãÂåñÁΩëÊ†ºÂØπË±°
    function resizeGrid(w, h) {
      if(w < 2 || h < 2) return; 

      // Ê∏ÖÁêÜ cursorGroup ‰∏≠ÁöÑÊóßÂØπË±°
      while(cursorGroup.children.length > 0){ 
        const c = cursorGroup.children[0];
        cursorGroup.remove(c);
        if(c.geometry) c.geometry.dispose();
      }

      state.planeW = Math.floor(w);
      state.planeH = Math.floor(h);

      offCanvas.width = state.planeW;
      offCanvas.height = state.planeH;

      const count = state.planeW * state.planeH;

      geometryParticles = new THREE.BufferGeometry();
      const pos = new Float32Array(count * 3);
      const col = new Float32Array(count * 3);
      
      for(let i=0; i<count; i++) {
        const x = i % state.planeW;
        const y = Math.floor(i / state.planeW);
        pos[i*3] = x - state.planeW/2;       
        pos[i*3+1] = (state.planeH/2) - y;   
        pos[i*3+2] = 0;
      }
      
      geometryParticles.setAttribute('position', new THREE.BufferAttribute(pos, 3));
      geometryParticles.setAttribute('color', new THREE.BufferAttribute(col, 3));
      pointsObj = new THREE.Points(geometryParticles, particlesMat);
      
      geometryMesh = new THREE.PlaneBufferGeometry(state.planeW, state.planeH, state.planeW - 1, state.planeH - 1);
      const meshCount = geometryMesh.attributes.position.count;
      geometryMesh.setAttribute('color', new THREE.BufferAttribute(new Float32Array(meshCount * 3), 3));
      meshObj = new THREE.Mesh(geometryMesh, meshMat);

      // Â∞ÜÂΩìÂâçÊ®°ÂºèÁöÑÂØπË±°Âä†ÂÖ•Âà∞ CursorGroup (Ë∑üÈöèÊâãÊú∫ËΩ¨Âä®)
      updateVisibility();
    }

    function updateVisibility() {
      // ÁÆÄÂçïÁ≤óÊö¥ÔºöÁßªÈô§ÊâÄÊúâÔºåÈáçÊñ∞Ê∑ªÂä†ÂΩìÂâçÊ®°Âºè
      cursorGroup.remove(pointsObj);
      cursorGroup.remove(meshObj);
      
      if (state.mode === 'points') cursorGroup.add(pointsObj);
      else cursorGroup.add(meshObj);
    }

    // --- Gyroscope Logic ---
    function enableSensor() {
      if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
        // iOS 13+ ÈúÄË¶ÅÊùÉÈôê
        DeviceOrientationEvent.requestPermission()
          .then(response => {
            if (response === 'granted') {
              window.addEventListener('deviceorientation', handleOrientation);
              activateSensorUI();
            } else {
              showToast("Permission Denied");
            }
          })
          .catch(console.error);
      } else {
        // Android / Old iOS
        window.addEventListener('deviceorientation', handleOrientation);
        activateSensorUI();
      }
    }

    function activateSensorUI() {
      state.isGyroEnabled = true;
      els.sensorFab.classList.add('active');
      els.statusDot.classList.add('gyro-active');
      showToast("Sensor Active: Turn your phone!");
      initialOffset = null; // ÈáçÁΩÆÂàùÂßãËßíÂ∫¶
    }

    function handleOrientation(event) {
      if (!state.isGyroEnabled) return;
      
      // ÁÆÄÂçïÁöÑËßíÂ∫¶Âπ≥ÊªëÂ§ÑÁêÜ
      const alpha = event.alpha ? THREE.MathUtils.degToRad(event.alpha) : 0; // ZËΩ¥ÊóãËΩ¨ (ÊåáÂçóÈíà)
      const beta = event.beta ? THREE.MathUtils.degToRad(event.beta) : 0;   // XËΩ¥ÊóãËΩ¨ (‰øØ‰ª∞)
      const gamma = event.gamma ? THREE.MathUtils.degToRad(event.gamma) : 0; // YËΩ¥ÊóãËΩ¨ (Ê®™Êªö)

      // Â¶ÇÊûúÊòØÁ¨¨‰∏ÄÊ¨°ÔºåËÆ∞ÂΩïÂàùÂßãÂÅèÁßªÈáèÔºåËÆ©ÁîªÈù¢‰øùÊåÅÂú®Ê≠£ÂâçÊñπ
      if (!initialOffset) {
        initialOffset = { alpha, beta, gamma };
      }

      // Â∫îÁî®ÊóãËΩ¨Âà∞ CursorGroup
      // Ê≥®ÊÑèÔºöÊ¨ßÊãâËßíÈ°∫Â∫èÂØπÊâãÊú∫Êù•ËØ¥ÂæàÈáçË¶ÅÔºåÈÄöÂ∏∏ ZXY Êàñ YXZ
      const euler = new THREE.Euler(beta - initialOffset.beta, alpha - initialOffset.alpha, -gamma + initialOffset.gamma, 'YXZ');
      cursorGroup.setRotationFromEuler(euler);
    }

    // --- Camera & Video ---
    async function startCamera() {
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) return;
      if (video.srcObject) video.srcObject.getTracks().forEach(track => track.stop());

      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: false, video: { facingMode: "environment" } });
        video.srcObject = stream;
        video.play();
        state.source = 'camera';
        updateStatus("Ready");
      } catch (err) {
        showToast("Camera Error: " + err.message);
      }
    }

    function setupImageLoader() {
      imgEl = new Image();
      imgEl.crossOrigin = "Anonymous"; 
      imgEl.onload = () => {
        state.imageLoaded = true;
        state.source = 'image';
        applyImageResolution();
      };
    }

    function applyImageResolution() {
      if (!state.imageLoaded) return;
      const aspect = imgEl.naturalWidth / imgEl.naturalHeight;
      const h = CONFIG.baseH * state.resScale;
      const w = aspect >= 1 ? Math.round(h * aspect) : h; // Keep it simpler
      resizeGrid(aspect >= 1 ? w : Math.round(h * aspect), h); 
    }

    // --- Animation Loop ---
    function animate() {
      requestAnimationFrame(animate);
      
      if(updateTexture()) {
        processGeometry(); // Êõ¥Êñ∞ Cursor
        
        // Ê†∏ÂøÉÔºöSlit Scan ÈÄªËæë
        if (state.isPainting) {
          paintFrame();
        }
        
        if (renderer.info.render.frame % 3 === 0) drawLumetric();
      }
      
      controls.update();
      renderer.render(scene, camera);
    }

    // Â∞ÜËßÜÈ¢ëÁ∫πÁêÜÁªòÂà∂Âà∞ Canvas Âπ∂Ëé∑ÂèñÊï∞ÊçÆ
    function updateTexture() {
      if (state.source === 'camera') {
        if (!video || video.readyState < 2 || video.videoWidth === 0) return false;
        const vw = video.videoWidth, vh = video.videoHeight;
        const cw = state.planeW, ch = state.planeH;
        const scale = Math.max(cw/vw, ch/vh);
        const dw = vw * scale, dh = vh * scale;
        offCtx.drawImage(video, (cw - dw)/2, (ch - dh)/2, dw, dh);
      } else {
        if (!state.imageLoaded) return false;
        offCtx.drawImage(imgEl, 0, 0, state.planeW, state.planeH);
      }
      return true;
    }

    // Êõ¥Êñ∞ÂÆûÊó∂È¢ÑËßàÁöÑÂá†‰Ωï‰Ωì (Cursor)
    function processGeometry() {
      const imgData = offCtx.getImageData(0, 0, state.planeW, state.planeH).data;
      const activeGeo = state.mode === 'points' ? geometryParticles : geometryMesh;
      if(!activeGeo) return;
      
      const posAttr = activeGeo.attributes.position;
      const colAttr = activeGeo.attributes.color;
      const count = posAttr.count;
      const extr = state.extrusion;

      for (let i = 0; i < count; i++) {
        const ptr = i * 4;
        const r = imgData[ptr], g = imgData[ptr+1], b = imgData[ptr+2];
        const lum = (0.299*r + 0.587*g + 0.114*b) / 255;
        
        // Cursor ÂßãÁªàÂú®ÂéüÁÇπÈôÑËøëÊòæÁ§∫ÔºåZËΩ¥Áî±‰∫ÆÂ∫¶ÂÜ≥ÂÆö
        posAttr.array[i*3+2] = lum * extr;
        colAttr.array[i*3] = r/255; 
        colAttr.array[i*3+1] = g/255; 
        colAttr.array[i*3+2] = b/255;
      }
      
      posAttr.needsUpdate = true;
      colAttr.needsUpdate = true;
      if (state.mode === 'mesh') {
        activeGeo.computeVertexNormals();
        activeGeo.attributes.normal.needsUpdate = true;
      }
    }

    // --- Ê†∏ÂøÉÔºöÁ©∫Èó¥ÁªòÂà∂ (The Magic) ---
    function paintFrame() {
      const now = Date.now();
      if (now - state.lastPaintTime < 40) return; // ÈôêÂà∂Â∏ßÁéá‰ª•Èò≤Â¥©Ê∫É
      state.lastPaintTime = now;

      // 1. ÂÖãÈöÜÂΩìÂâç Cursor ÁöÑÂá†‰Ωï‰Ωì
      let newObj;
      const srcObj = state.mode === 'points' ? pointsObj : meshObj;
      
      if (state.mode === 'points') {
        newObj = new THREE.Points(srcObj.geometry.clone(), particlesMat.clone());
      } else {
        newObj = new THREE.Mesh(srcObj.geometry.clone(), meshMat.clone());
      }

      // 2. Â∞Ü Cursor ÂΩìÂâçÁöÑÊóãËΩ¨Â∫îÁî®Âà∞Êñ∞ÂØπË±°‰∏ä
      // Ëøô‰∏ÄÊ≠•ËÆ©Êñ∞ÁîüÊàêÁöÑÁΩëÊ†º‚ÄúËÆ∞‰Ωè‚Äù‰∫ÜÂÆÉÁîüÊàêÊó∂ÁöÑËßíÂ∫¶
      newObj.rotation.copy(cursorGroup.rotation);
      newObj.position.copy(cursorGroup.position);

      // 3. Â∞ÜÊñ∞ÂØπË±°Âä†ÂÖ•Âà∞ WorldGroup (ÈùôÊÄÅ‰∏ñÁïå)
      worldGroup.add(newObj);

      // 4. Ê®°ÊãüË°åËµ∞ÔºöÂ∞Ü WorldGroup ‰∏≠ÁöÑÊâÄÊúâÁâ©‰ΩìÂêëÂêéÊé®Áßª
      // ÊàñËÄÖÊõ¥ÁÆÄÂçïÔºöÂ∞ÜÊñ∞Áâ©‰ΩìÁ®çÂæÆÊîæÂêéÈù¢‰∏ÄÁÇπÔºü‰∏çÔºåÊï¥‰∏™‰∏ñÁïåÂêéÈÄÄÊïàÊûúÊúÄÂ•Ω
      // ‰∏∫‰∫ÜÊÄßËÉΩÔºåÊàë‰ª¨ÁßªÂä®Êï¥‰∏™ worldGroup ÁöÑÂ≠êÂØπË±°ÊØîËæÉÊÖ¢Ôºå
      // Êõ¥È´òÊïàÁöÑÊñπÊ≥ïÊòØÁßªÂä® newObj Ëá™Ë∫´„ÄÇ
      
      // Á≠ñÁï•Ôºö
      // ÊØè‰∏ÄÂ∏ßÔºåÊàë‰ª¨ÊääÊñ∞‰∫ßÁîüÁöÑÂØπË±°ÊîæÂú® (0,0,0)„ÄÇ
      // ‰ΩÜÊòØ‰πãÂâç‰∫ßÁîüÁöÑÂØπË±°ÈúÄË¶ÅÊ†πÊçÆ "Scan Speed" Ê≤øÁùÄÂÆÉ‰ª¨Ëá™Â∑±ÁöÑÂ±ÄÈÉ® Z ËΩ¥ÊàñËÄÖ‰∏ñÁïå Z ËΩ¥ÁßªÂä®„ÄÇ
      
      // ÂÆûÁé∞‚ÄúÊó∂Èó¥ÈößÈÅì‚ÄùÊïàÊûúÔºö
      // Êàë‰ª¨Êää worldGroup ÈáåÁöÑÊâÄÊúâÂ≠©Â≠êÔºåÊ≤øÁùÄÂÆÉ‰ª¨ÂêÑËá™ÁöÑÊ≥ïÁ∫øÊñπÂêëÔºåÊàñËÄÖÁªü‰∏ÄÂêëÂêéÁßªÂä®„ÄÇ
      // ÊúÄÁÆÄÂçïÁöÑÊ®°ÊãüË°åËµ∞ÔºöÊää worldGroup ÈáåÁöÑÊâÄÊúâ‰∏úË•øÂæÄ Z ËΩ¥Ê∑±Â§ÑÊé®„ÄÇ
      
      // *** ÂÖ≥ÈîÆÁÆóÊ≥ï ***
      // ‰∏∫‰∫ÜËÆ©ËΩ¨ÂºØÂêéÁöÑËΩ®ËøπÊé•‰∏äÔºåÊàë‰ª¨ÈúÄË¶ÅËÆ©Êï¥‰∏™ worldGroup ÂêëÁùÄ‚ÄúÂΩìÂâçÂÖâÊ†áÁöÑÂêéÊñπ‚ÄùÁßªÂä®„ÄÇ
      // ËøôÊúâÁÇπÂ§çÊùÇÔºåÁÆÄÂçïÁöÑËøë‰ººÊòØÔºöËÆ©ÊâÄÊúâÂ∑≤ÁªèÁîªÂ•ΩÁöÑ‰∏úË•øÔºåÊ≤øÁùÄ Z ËΩ¥ÂêéÈÄÄ„ÄÇ
      
      const speed = state.scanSpeed;
      
      // ÁßªÂä®Â∑≤ÊúâËΩ®Ëøπ
      worldGroup.children.forEach(child => {
        // ÁÆÄÂçïÊñπÊ°àÔºöÁõ¥Êé•Âêë‰∏ñÁïå Z ËΩ¥Ê∑±Â§ÑÁßªÂä® (Á±ª‰ºº‰º†ÈÄÅÂ∏¶)
        // ËøôÂú®ËΩ¨ÂºØÊó∂‰ºö‰∫ßÁîü‰∏ÄÁßçÂ•áÂºÇÁöÑËâ∫ÊúØÊïàÊûú (Slit-scan aesthetic)
        child.position.z -= speed;
      });

      // 5. ÂÜÖÂ≠òÁÆ°ÁêÜÔºöÁßªÈô§Â§™ËøúÁöÑÂØπË±°
      if (worldGroup.children.length > 80) {
        const old = worldGroup.children.shift();
        old.geometry.dispose();
        worldGroup.remove(old);
      }
    }

    // --- UI Actions ---
    function setupUI() {
      const toggleMenu = () => els.sheet.classList.toggle('collapsed');
      els.sheetToggle.addEventListener('click', (e) => { e.stopPropagation(); toggleMenu(); });
      renderer.domElement.addEventListener('click', () => els.sheet.classList.add('collapsed'));

      // ‰º†ÊÑüÂô®ÂºÄÂÖ≥
      els.sensorFab.addEventListener('click', () => {
        if (!state.isGyroEnabled) enableSensor();
        else {
          // ÂèØ‰ª•Âú®ËøôÈáåÂÅöÂÖ≥Èó≠ÈÄªËæëÔºåÊàñËÄÖÈáçÁΩÆÊ†°ÂáÜ
          showToast("Sensor Recalibrated");
          initialOffset = null; 
        }
      });

      // ÁªòÂà∂ÂºÄÂÖ≥
      els.paintFab.addEventListener('click', () => {
        state.isPainting = !state.isPainting;
        if(state.isPainting) {
          els.paintFab.classList.add('paint-btn');
          els.paintFab.innerText = "üõë Stop";
          els.statusDot.className = "dot recording";
          els.sourceText.innerText = "Scanning...";
        } else {
          els.paintFab.classList.remove('paint-btn');
          els.paintFab.innerText = "üñåÔ∏è REC";
          els.statusDot.className = state.isGyroEnabled ? "dot gyro-active" : "dot";
          els.sourceText.innerText = "Ready";
        }
      });

      els.clearFab.addEventListener('click', () => {
        while(worldGroup.children.length > 0){ 
          const c = worldGroup.children[0];
          worldGroup.remove(c); c.geometry.dispose();
        }
        showToast("Scene Cleared");
      });

      els.camResetBtn.addEventListener('click', startCamera);

      els.modeBtn.addEventListener('click', () => {
        state.mode = state.mode === 'mesh' ? 'points' : 'mesh';
        els.modeBtn.innerText = state.mode === 'mesh' ? 'View Points' : 'View Mesh';
        updateVisibility();
      });

      els.sliders.ext.addEventListener('input', (e) => { state.extrusion = e.target.value; els.vals.ext.innerText = e.target.value; });
      els.sliders.speed.addEventListener('input', (e) => { state.scanSpeed = e.target.value; els.vals.speed.innerText = e.target.value; });
      els.sliders.size.addEventListener('input', (e) => { state.pointSize = e.target.value; particlesMat.size = e.target.value; els.vals.size.innerText = parseFloat(e.target.value).toFixed(1); });
      els.exportBtn.addEventListener('click', performExport);
    }

    function updateStatus(text) { els.sourceText.innerText = text; }
    function showToast(msg) { els.toast.innerText = msg; els.toast.style.opacity = 1; setTimeout(() => els.toast.style.opacity = 0, 3000); }

    function performExport() {
      showToast("Merging & Saving...");
      setTimeout(() => {
        try {
          const timestamp = Date.now();
          offCanvas.toBlob(b => downloadBlob(b, `scan_${timestamp}.jpg`), 'image/jpeg', 0.95);

          const allMeshes = [...worldGroup.children];
          if(state.mode === 'points') allMeshes.push(pointsObj);
          else allMeshes.push(meshObj);

          let geometries = [];
          allMeshes.forEach(obj => {
            const g = obj.geometry.clone();
            obj.updateMatrixWorld();
            g.applyMatrix4(obj.matrixWorld);
            if(!g.attributes.color) {
               const count = g.attributes.position.count;
               g.setAttribute('color', new THREE.BufferAttribute(new Float32Array(count*3).fill(1), 3));
            }
            geometries.push(g);
          });

          if(geometries.length === 0) return;
          const merged = THREE.BufferGeometryUtils.mergeBufferGeometries(geometries);

          if(state.mode === 'points') {
             // Export logic for points (simplified for brevity)
             // Use same logic as previous version
             const exporter = new THREE.PLYExporter();
             // Hack: convert buffergeo to points to export
             const p = new THREE.Points(merged, particlesMat);
             exporter.parse(p, res => downloadBlob(new Blob([res]), `scan_${timestamp}.ply`), { binary: true });
          } else {
             const exporter = new THREE.PLYExporter();
             const m = new THREE.Mesh(merged, meshMat);
             exporter.parse(m, res => downloadBlob(new Blob([res]), `scan_${timestamp}.ply`), { binary: true });
          }
        } catch(e) { console.error(e); showToast("Export Error"); }
      }, 100);
    }

    function downloadBlob(blob, name) {
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = name;
      a.click();
    }

    function drawLumetric() {
      const ctx = els.waveform;
      const w = ctx.canvas.width, h = ctx.canvas.height;
      ctx.fillStyle = 'rgba(0,0,0,1)'; ctx.fillRect(0,0,w,h);
      const data = offCtx.getImageData(0,0,state.planeW,state.planeH).data;
      ctx.fillStyle = state.isPainting ? '#FFD60A' : '#0A84FF';
      for(let x=0; x<w; x++) {
        const srcX = Math.floor(x*(state.planeW/w));
        for(let y=0; y<state.planeH; y+=20) {
           const i = (y*state.planeW+srcX)*4;
           if(i<data.length) {
             const l = (0.299*data[i]+0.587*data[i+1]+0.114*data[i+2])/255;
             ctx.fillRect(x, h-(l*h), 1, 1.5);
           }
        }
      }
    }
  </script>
</body>
</html>
