<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
  <title>Lumetric Slit-Scan</title>
  
  <style>
    /* =========================================
       CSS STYLES
       ========================================= */
    :root {
      --bg-color: #000000;
      --glass-bg: rgba(20, 20, 20, 0.85);
      --glass-border: rgba(255, 255, 255, 0.15);
      --accent: #0A84FF;
      --danger: #FF453A;
      --active: #FFD60A; /* Yellow for painting */
      --text-main: #FFFFFF;
      --radius: 16px;
    }

    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; outline: none; user-select: none; }
    
    body {
      margin: 0; overflow: hidden; background: var(--bg-color);
      font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", Roboto, sans-serif;
      color: var(--text-main);
    }

    #mainCanvas {
      display: block; width: 100vw; height: 100vh; touch-action: none;
      position: absolute; top: 0; left: 0; z-index: 1;
    }

    /* È°∂ÈÉ® UI */
    .top-ui {
      position: absolute; top: env(safe-area-inset-top, 15px); 
      left: 15px; right: 15px;
      display: flex; justify-content: space-between; align-items: flex-start;
      z-index: 10; pointer-events: none;
    }

    .status-badge {
      font-size: 12px; font-weight: 600;
      background: rgba(0,0,0,0.6); backdrop-filter: blur(8px);
      padding: 6px 12px; border-radius: 20px;
      display: flex; align-items: center; gap: 8px;
      border: 1px solid var(--glass-border);
      height: 32px;
      pointer-events: auto;
    }
    .dot { width: 6px; height: 6px; background: #32D74B; border-radius: 50%; box-shadow: 0 0 5px #32D74B; }
    .dot.inactive { background: #FF453A; box-shadow: none; }
    .dot.painting { background: var(--active); box-shadow: 0 0 8px var(--active); animation: pulse 1s infinite; }

    @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }

    .right-ui-group {
      display: flex; flex-direction: column; align-items: flex-end; gap: 10px;
      pointer-events: auto;
    }

    /* ÂäüËÉΩÊåâÈíÆÁªÑ */
    .fab-group { display: flex; gap: 10px; }

    .fab {
      height: 44px; padding: 0 16px;
      background: rgba(255, 255, 255, 0.15);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 22px;
      display: flex; justify-content: center; align-items: center;
      font-size: 14px; font-weight: 600; cursor: pointer;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      transition: all 0.2s;
      color: var(--text-main);
    }
    .fab:active { transform: scale(0.95); }
    
    /* ÁªòÂà∂ÊåâÈíÆÊøÄÊ¥ªÁä∂ÊÄÅ */
    .fab.active-paint {
      background: var(--active);
      color: #000;
      border-color: var(--active);
    }
    
    /* Ê∏ÖÈô§ÊåâÈíÆ */
    .fab.clear-btn {
      width: 44px; padding: 0; color: var(--danger); border-color: rgba(255, 69, 58, 0.3);
    }

    .lumetric-box {
      background: rgba(0, 0, 0, 0.7);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 8px;
      backdrop-filter: blur(4px);
      padding: 2px;
    }
    #waveformCanvas { width: 100px !important; height: 50px !important; display: block; }

    /* Â∫ïÈÉ®Èù¢Êùø */
    .control-sheet {
      position: absolute; bottom: 0; left: 0; right: 0;
      background: var(--glass-bg);
      backdrop-filter: blur(25px); -webkit-backdrop-filter: blur(25px);
      border-radius: var(--radius) var(--radius) 0 0;
      border-top: 1px solid var(--glass-border);
      padding: 15px 20px calc(20px + env(safe-area-inset-bottom));
      z-index: 20;
      transition: transform 0.3s cubic-bezier(0.16, 1, 0.3, 1);
      max-height: 70vh; overflow-y: auto;
      transform: translateY(0);
    }
    .control-sheet.collapsed { transform: translateY(calc(100% - 40px)); }

    .sheet-handle-area {
      width: 100%; height: 30px; position: absolute; top: 0; left: 0;
      display: flex; justify-content: center; align-items: center;
      cursor: pointer; z-index: 30;
    }
    .sheet-handle { width: 40px; height: 5px; background: rgba(255,255,255,0.3); border-radius: 10px; }

    .actions-grid {
      display: grid; grid-template-columns: 1fr 1fr; gap: 10px;
      margin-top: 20px; margin-bottom: 20px;
    }

    .btn {
      background: rgba(255,255,255,0.12); border: none;
      color: var(--text-main); padding: 14px; border-radius: 10px;
      font-size: 13px; font-weight: 500; cursor: pointer; text-align: center;
    }
    .btn:active { background: rgba(255,255,255,0.25); }
    .btn.primary { background: var(--text-main); color: #000; font-weight: 600; }
    .btn.accent { background: var(--accent); color: #fff; font-weight: 600; }

    .file-upload { position: relative; overflow: hidden; }
    .file-upload input { position: absolute; left: 0; top: 0; width: 100%; height: 100%; opacity: 0; }

    .slider-container { margin-bottom: 18px; }
    .slider-label {
      display: flex; justify-content: space-between;
      font-size: 12px; color: rgba(255,255,255,0.6); margin-bottom: 8px;
    }
    .slider-value { color: var(--text-main); font-weight: 600; font-family: monospace; }
    
    input[type=range] { -webkit-appearance: none; appearance: none; width: 100%; background: transparent; }
    input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 4px; background: rgba(255,255,255,0.2); border-radius: 2px; }
    input[type=range]::-webkit-slider-thumb {
      -webkit-appearance: none; appearance: none; height: 20px; width: 20px; border-radius: 50%;
      background: #fff; margin-top: -8px; box-shadow: 0 2px 8px rgba(0,0,0,0.5);
    }
    
    #toast {
      position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.9); color: white; padding: 10px 20px;
      border-radius: 30px; font-size: 13px; opacity: 0; pointer-events: none;
      transition: opacity 0.3s; z-index: 100; backdrop-filter: blur(10px);
      border: 1px solid rgba(255,255,255,0.1);
      text-align: center; width: 80%;
    }
  </style>
</head>
<body>

  <div id="toast">Ready</div>

  <div class="top-ui">
    <div class="status-badge">
      <span class="dot" id="statusDot"></span>
      <span id="sourceText">Ready</span>
    </div>
    
    <div class="right-ui-group">
      <div class="fab-group">
        <div class="fab clear-btn" id="clearFab" title="Clear Scan">üóëÔ∏è</div>
        <div class="fab" id="paintFab" title="Hold to Paint">üñåÔ∏è Paint</div>
        <div class="fab" id="camFab" title="Start/Reset Camera">üì∑</div>
      </div>
      
      <div class="lumetric-box">
        <canvas id="waveformCanvas" width="200" height="100"></canvas>
      </div>
    </div>
  </div>

  <div class="control-sheet" id="controlSheet">
    <div class="sheet-handle-area" id="sheetToggle">
      <div class="sheet-handle"></div>
    </div>

    <div class="actions-grid">
      <button class="btn primary" id="toggleModeBtn">View Points</button>
      <button class="btn accent" id="exportBtn">Export All</button>
      <button class="btn" id="switchSourceBtn">Switch Mode</button>
      <div class="btn file-upload">
        Load Image
        <input type="file" id="imageInput" accept="image/*">
      </div>
    </div>

    <div class="slider-container">
      <div class="slider-label"><span>Extrusion Z</span><span class="slider-value" id="extrusionVal">300</span></div>
      <input type="range" id="extrusionSlider" min="0" max="800" value="300">
    </div>

    <div class="slider-container">
      <div class="slider-label"><span>Scan Speed</span><span class="slider-value" id="speedVal">20</span></div>
      <input type="range" id="speedSlider" min="0" max="100" value="20" step="5">
    </div>

    <div class="slider-container">
      <div class="slider-label"><span>Point Size</span><span class="slider-value" id="pointSizeVal">2.0</span></div>
      <input type="range" id="pointSizeSlider" min="1" max="10" value="2" step="0.5">
    </div>

    <div class="slider-container" id="resContainer" style="opacity:0.5; pointer-events:none;">
      <div class="slider-label"><span>Image Quality</span><span class="slider-value" id="resVal">1x</span></div>
      <input type="range" id="resSlider" min="1" max="4" value="1" step="1">
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/utils/BufferGeometryUtils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/PLYExporter.js"></script>

  <script>
    const CONFIG = {
      baseW: 320, 
      baseH: 240,
      bgColor: 0x050505
    };

    let scene, camera, renderer, controls;
    let video, imgEl;
    let geometryParticles, geometryMesh, pointsObj, meshObj;
    let particlesMat, meshMat;
    let paintedGroup; // Áî®‰∫éÂ≠òÊîæÁªòÂà∂ÁöÑËΩ®Ëøπ
    
    let state = {
      mode: 'mesh', // 'mesh' or 'points'
      source: 'camera', 
      extrusion: 300,
      pointSize: 2,
      resScale: 1,
      imageLoaded: false,
      planeW: 0,
      planeH: 0,
      isPainting: false, // ÊòØÂê¶Ê≠£Âú®ÁªòÂà∂
      lastPaintTime: 0,
      scanSpeed: 20 // Êâ´ÊèèÂêéÈÄÄÈÄüÂ∫¶
    };

    const offCanvas = document.createElement('canvas');
    const offCtx = offCanvas.getContext('2d', { willReadFrequently: true });
    
    const els = {
      sheet: document.getElementById('controlSheet'),
      sheetToggle: document.getElementById('sheetToggle'),
      camFab: document.getElementById('camFab'),
      paintFab: document.getElementById('paintFab'),
      clearFab: document.getElementById('clearFab'),
      modeBtn: document.getElementById('toggleModeBtn'),
      exportBtn: document.getElementById('exportBtn'),
      switchBtn: document.getElementById('switchSourceBtn'),
      imgInput: document.getElementById('imageInput'),
      sliders: {
        ext: document.getElementById('extrusionSlider'),
        size: document.getElementById('pointSizeSlider'),
        res: document.getElementById('resSlider'),
        speed: document.getElementById('speedSlider')
      },
      vals: {
        ext: document.getElementById('extrusionVal'),
        size: document.getElementById('pointSizeVal'),
        res: document.getElementById('resVal'),
        speed: document.getElementById('speedVal')
      },
      resContainer: document.getElementById('resContainer'),
      sourceText: document.getElementById('sourceText'),
      statusDot: document.getElementById('statusDot'),
      waveform: document.getElementById('waveformCanvas').getContext('2d'),
      toast: document.getElementById('toast')
    };

    init();
    animate();

    function init() {
      // 1. Check HTTPS
      if (location.protocol !== 'https:' && location.hostname !== 'localhost' && location.hostname !== '127.0.0.1') {
         alert("‰∏•ÈáçË≠¶ÂëäÔºöÊëÑÂÉèÂ§¥ÂäüËÉΩÂøÖÈ°ªÂú® HTTPS ÁéØÂ¢É‰∏ãËøêË°åÔºÅ");
      }

      scene = new THREE.Scene();
      scene.background = new THREE.Color(CONFIG.bgColor);

      camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 10000);
      camera.position.set(0, 0, 600);

      renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.domElement.id = 'mainCanvas';
      document.body.appendChild(renderer.domElement);

      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.enablePan = false;
      
      particlesMat = new THREE.PointsMaterial({ size: state.pointSize, vertexColors: true });
      meshMat = new THREE.MeshPhongMaterial({ 
        vertexColors: true, side: THREE.DoubleSide, 
        shininess: 30, flatShading: true 
      });

      // Group for painted strokes
      paintedGroup = new THREE.Group();
      scene.add(paintedGroup);

      scene.add(new THREE.AmbientLight(0xffffff, 0.5));
      const dirLight = new THREE.DirectionalLight(0xffffff, 1);
      dirLight.position.set(0, 200, 200);
      scene.add(dirLight);

      resizeGrid(CONFIG.baseW, CONFIG.baseH);
      
      video = document.createElement('video');
      video.autoplay = true; video.muted = true; video.playsInline = true; 

      setupImageLoader();
      setupUI();
      startCamera();
      
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    }

    function resizeGrid(w, h) {
      if(w < 2 || h < 2) return; 

      if (pointsObj) { scene.remove(pointsObj); geometryParticles.dispose(); }
      if (meshObj) { scene.remove(meshObj); geometryMesh.dispose(); }

      state.planeW = Math.floor(w);
      state.planeH = Math.floor(h);

      offCanvas.width = state.planeW;
      offCanvas.height = state.planeH;

      const count = state.planeW * state.planeH;

      geometryParticles = new THREE.BufferGeometry();
      const pos = new Float32Array(count * 3);
      const col = new Float32Array(count * 3);
      
      for(let i=0; i<count; i++) {
        const x = i % state.planeW;
        const y = Math.floor(i / state.planeW);
        pos[i*3] = x - state.planeW/2;       
        pos[i*3+1] = (state.planeH/2) - y;   
        pos[i*3+2] = 0;
      }
      
      geometryParticles.setAttribute('position', new THREE.BufferAttribute(pos, 3));
      geometryParticles.setAttribute('color', new THREE.BufferAttribute(col, 3));
      // Áî®‰∫éÊ†áËÆ∞Âì™‰∫õÁÇπÊòØÊúâÊïàÁöÑÔºàÊØîÂ¶ÇÈªëËâ≤ËÉåÊôØÂèØ‰ª•ÂâîÈô§ÔºåËøôÈáåÊöÇ‰øùÁïôÂÖ®ÈÉ®Ôºâ
      pointsObj = new THREE.Points(geometryParticles, particlesMat);
      // ÂÆûÊó∂È¢ÑËßàÁöÑÁâ©‰Ωì‰∏çÈúÄË¶ÅÂä†ÂÖ• paintedGroupÔºåÁõ¥Êé•Âä†Âà∞scene
      scene.add(pointsObj);

      geometryMesh = new THREE.PlaneBufferGeometry(state.planeW, state.planeH, state.planeW - 1, state.planeH - 1);
      const meshCount = geometryMesh.attributes.position.count;
      geometryMesh.setAttribute('color', new THREE.BufferAttribute(new Float32Array(meshCount * 3), 3));
      meshObj = new THREE.Mesh(geometryMesh, meshMat);
      scene.add(meshObj);

      updateVisibility();
    }

    function updateVisibility() {
      pointsObj.visible = state.mode === 'points';
      meshObj.visible = state.mode === 'mesh';
    }

    // --- Core Logic ---
    async function startCamera() {
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) return;
      if (video.srcObject) video.srcObject.getTracks().forEach(track => track.stop());

      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: false, video: { facingMode: "environment" } });
        handleStream(stream);
      } catch (err) {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ audio: false, video: true });
          handleStream(stream);
        } catch (err2) {
          showToast("Camera access failed");
          state.source = 'image';
          updateUIMode();
        }
      }
    }

    function handleStream(stream) {
        video.srcObject = stream;
        video.play().catch(e => console.error(e));
        state.source = 'camera';
        updateUIMode();
        updateStatus(true, "Ready");
        resizeGrid(CONFIG.baseW, CONFIG.baseH);
    }

    function setupImageLoader() {
      imgEl = new Image();
      imgEl.crossOrigin = "Anonymous"; 
      imgEl.onload = () => {
        state.imageLoaded = true;
        state.source = 'image';
        applyImageResolution();
        updateUIMode();
      };
    }

    function applyImageResolution() {
      if (!state.imageLoaded) return;
      const aspect = imgEl.naturalWidth / imgEl.naturalHeight;
      const scale = state.resScale;
      const baseH = CONFIG.baseH * scale;
      let w, h;
      if (aspect >= 1) { h = baseH; w = Math.round(h * aspect); } 
      else { w = baseH; h = Math.round(w / aspect); }
      resizeGrid(w, h);
    }

    function animate() {
      requestAnimationFrame(animate);
      
      const hasNewFrame = updateTexture();
      
      if(hasNewFrame) {
        processGeometry(); // Êõ¥Êñ∞ÂÆûÊó∂È¢ÑËßà
        if (state.isPainting) paintFrame(); // ÁªòÂà∂ÈÄªËæë
        if (renderer.info.render.frame % 3 === 0) drawLumetric();
      }
      
      controls.update();
      renderer.render(scene, camera);
    }

    function updateTexture() {
      if (state.source === 'camera') {
        if (!video || video.readyState < 2 || video.videoWidth === 0) return false;
        const vw = video.videoWidth, vh = video.videoHeight;
        const cw = state.planeW, ch = state.planeH;
        const scale = Math.max(cw/vw, ch/vh);
        const dw = vw * scale, dh = vh * scale;
        offCtx.drawImage(video, (cw - dw)/2, (ch - dh)/2, dw, dh);
      } else {
        if (!state.imageLoaded) return false;
        offCtx.drawImage(imgEl, 0, 0, state.planeW, state.planeH);
      }
      return true;
    }

    function processGeometry() {
      const imgData = offCtx.getImageData(0, 0, state.planeW, state.planeH).data;
      const activeGeo = state.mode === 'points' ? geometryParticles : geometryMesh;
      if(!activeGeo) return;
      
      const posAttr = activeGeo.attributes.position;
      const colAttr = activeGeo.attributes.color;
      const count = posAttr.count;
      if (imgData.length < count * 4) return;

      const extr = state.extrusion;
      
      // Êõ¥Êñ∞ Z ËΩ¥Êï∞ÊçÆÂíåÈ¢úËâ≤
      for (let i = 0; i < count; i++) {
        const ptr = i * 4;
        const r = imgData[ptr], g = imgData[ptr+1], b = imgData[ptr+2];
        const lum = (0.299*r + 0.587*g + 0.114*b) / 255;
        
        posAttr.array[i*3+2] = lum * extr; // ÂÆûÊó∂È¢ÑËßàÂßãÁªàÂú® Z=0 ÈôÑËøëÂèòÂåñ
        colAttr.array[i*3] = r/255; 
        colAttr.array[i*3+1] = g/255; 
        colAttr.array[i*3+2] = b/255;
      }
      
      posAttr.needsUpdate = true;
      colAttr.needsUpdate = true;
      
      if (state.mode === 'mesh') {
        activeGeo.computeVertexNormals();
        activeGeo.attributes.normal.needsUpdate = true;
      }
    }

    // --- Ê†∏ÂøÉÁªòÂà∂ÈÄªËæë (Slit Scan) ---
    function paintFrame() {
      const now = Date.now();
      // ÈôêÂà∂ÁªòÂà∂È¢ëÁéá (‰æãÂ¶ÇÊØè 50ms ‰∏ÄÂ∏ß)
      if (now - state.lastPaintTime < 50) return;
      state.lastPaintTime = now;

      // 1. Â∞ÜÂ∑≤ÊúâÁöÑÊâÄÊúâÁªòÂà∂Â±ÇÂêëÂêéÊé®Áßª (Time Tunnel Effect)
      // ËøôÊ†∑Êñ∞ÁöÑÂ∏ßÊÄªÊòØÁîªÂú®ÂâçÈù¢ÔºåÊóßÁöÑÂêëÊ∑±Â§ÑÁßªÂä®
      const moveDist = state.scanSpeed;
      if (moveDist > 0) {
        paintedGroup.children.forEach(child => {
          child.position.z -= moveDist; 
        });
      }

      // 2. ÂÖãÈöÜÂΩìÂâçÁöÑÂá†‰Ωï‰Ωì
      let newObj;
      
      // ‰∏∫‰∫ÜÊÄßËÉΩÔºåÁªòÂà∂Ê®°ÂºèÈÄöÂ∏∏Âª∫ËÆÆ‰ΩøÁî® PointsÔºåMesh ‰ºöÈùûÂ∏∏Âç°
      // ‰ΩÜËøôÈáåÊ†πÊçÆÂΩìÂâçÊ®°ÂºèÂÜ≥ÂÆö
      if (state.mode === 'points') {
        const geoClone = geometryParticles.clone();
        newObj = new THREE.Points(geoClone, particlesMat.clone()); // ÊùêË¥®‰πüÂÖãÈöÜ‰ª•Èò≤‰∫íÁõ∏ÂΩ±Âìç(ÂèØÈÄâ)
      } else {
        // Mesh Ê®°ÂºèÔºöÂÖãÈöÜ Mesh Âá†‰Ωï‰Ωì
        const geoClone = geometryMesh.clone();
        newObj = new THREE.Mesh(geoClone, meshMat.clone());
      }

      // 3. Â∞ÜÊñ∞ÂØπË±°Ê∑ªÂä†Âà∞ÁªÑ
      // ÂÆÉÁöÑ‰ΩçÁΩÆÂàùÂßãÊòØ (0,0,0) (Áõ∏ÂØπ‰∫é paintedGroup)ÔºåÊ≠£Â•ΩÂú®Áõ∏Êú∫ÂâçÊñπ
      paintedGroup.add(newObj);

      // 4. ÊÄßËÉΩ‰øùÊä§ÔºöÂ¶ÇÊûúÂ±ÇÊï∞Â§™Â§öÔºåÁßªÈô§ÊúÄËøúÁöÑÔºàÂèØÈÄâÔºâ
      if (paintedGroup.children.length > 60) {
        const old = paintedGroup.children.shift(); // ÁßªÈô§ÊúÄÊó©ÁöÑ
        if (old.geometry) old.geometry.dispose();
        if (old.material) old.material.dispose();
        paintedGroup.remove(old);
      }
    }

    function clearPaint() {
      // Ê∏ÖÁ©∫ÊâÄÊúâÁªòÂà∂
      while(paintedGroup.children.length > 0){ 
        const child = paintedGroup.children[0];
        paintedGroup.remove(child);
        if(child.geometry) child.geometry.dispose();
      }
      showToast("Scan Cleared");
    }

    // --- ÂØºÂá∫ÈÄªËæë (ÂêàÂπ∂ÊâÄÊúâÂ±Ç) ---
    function performExport() {
      showToast("Merging & Saving...");
      setTimeout(() => {
        try {
          const timestamp = Date.now();
          
          // 1. ‰∏ãËΩΩÂèÇËÄÉÂõæ
          offCanvas.toBlob((blob) => {
            if(blob) downloadBlob(blob, `scan_ref_${timestamp}.jpg`);
          }, 'image/jpeg', 0.95);

          // 2. Êî∂ÈõÜÊâÄÊúâË¶ÅÂØºÂá∫ÁöÑÂØπË±° (ÂÆûÊó∂È¢ÑËßà + ÁªòÂà∂ÁöÑÂéÜÂè≤ËΩ®Ëøπ)
          // Ê≥®ÊÑèÔºöÈúÄË¶ÅÂ∫îÁî®ÂÆÉ‰ª¨ÁöÑ transforms (‰ΩçÁΩÆÂÅèÁßª) Âà∞Âá†‰Ωï‰ΩìÊï∞ÊçÆ‰∏≠
          let geometriesToMerge = [];
          const allObjects = [...paintedGroup.children];
          
          // ÊòØÂê¶ÂåÖÂê´ÂΩìÂâçÁöÑÂÆûÊó∂È¢ÑËßàÂ∏ßÔºüÈÄöÂ∏∏ÊòØÁöÑ
          if (state.mode === 'points') allObjects.push(pointsObj);
          else allObjects.push(meshObj);

          // ÈÅçÂéÜÂπ∂ÂáÜÂ§áÂêàÂπ∂
          allObjects.forEach(obj => {
            if (!obj.visible) return;
            
            const g = obj.geometry.clone();
            // Â∫îÁî®ÂΩìÂâçÂØπË±°Âú®‰∏ñÁïåÁ©∫Èó¥‰∏≠ÁöÑÂèòÊç¢Áü©Èòµ (Â§ÑÁêÜ‰ΩçÁßª)
            obj.updateMatrixWorld();
            g.applyMatrix4(obj.matrixWorld);
            
            // Á°Æ‰øùÈÉΩÊúâ color Â±ûÊÄß
            if (!g.attributes.color) {
                // Â¶ÇÊûúÊ≤°ÊúâÈ¢úËâ≤ÔºåÂ°´ÂÖÖÁôΩËâ≤ (Èò≤Èîô)
                const count = g.attributes.position.count;
                const colors = new Float32Array(count * 3).fill(1);
                g.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            }
            
            geometriesToMerge.push(g);
          });

          if (geometriesToMerge.length === 0) { showToast("Nothing to export"); return; }

          // ÂêàÂπ∂Âá†‰Ωï‰Ωì
          // Ê≥®ÊÑèÔºöThree.js ÁöÑ mergeBufferGeometries Ë¶ÅÊ±ÇÂ±ûÊÄß‰∏ÄËá¥„ÄÇ
          // Êàë‰ª¨ÁöÑÁîüÊàêÈÄªËæë‰øùËØÅ‰∫ÜÂÆÉ‰ª¨ÈÉΩÊòØÂêåÊûÑÁöÑ„ÄÇ
          const mergedGeo = THREE.BufferGeometryUtils.mergeBufferGeometries(geometriesToMerge);

          if (state.mode === 'points') {
             // ÂØºÂá∫ PTS
             const pos = mergedGeo.attributes.position.array;
             const col = mergedGeo.attributes.color.array;
             const cnt = mergedGeo.attributes.position.count;
             let output = "";
             // ÈôêÂà∂ÂØºÂá∫Â§ßÂ∞èÔºåÈò≤Ê≠¢Â¥©Ê∫É (ptsÊòØÁ∫ØÊñáÊú¨ÔºåÂæàÂ§ß)
             const step = cnt > 200000 ? 2 : 1; // ÁÆÄÂçïÈôçÈááÊ†∑
             for(let i=0; i<cnt; i+=step) {
               const x = pos[i*3], y = pos[i*3+1], z = pos[i*3+2];
               const r = Math.floor(col[i*3]*255), g = Math.floor(col[i*3+1]*255), b = Math.floor(col[i*3+2]*255);
               output += `${x.toFixed(3)} ${y.toFixed(3)} ${z.toFixed(3)} ${r} ${g} ${b}\n`;
             }
             downloadBlob(new Blob([output], {type: 'text/plain'}), `scan_merged_${timestamp}.asc`);
          } else {
             // ÂØºÂá∫ PLY
             const exporter = new THREE.PLYExporter();
             const tempMesh = new THREE.Mesh(mergedGeo, meshMat);
             exporter.parse(tempMesh, (res) => {
               downloadBlob(new Blob([res], {type: 'text/plain'}), `scan_merged_${timestamp}.ply`);
             });
          }
          
          // Ê∏ÖÁêÜÂÜÖÂ≠ò
          mergedGeo.dispose();
          geometriesToMerge.forEach(g => g.dispose());

        } catch(e) {
          console.error(e);
          showToast("Export Failed (Memory Limit?)");
        }
      }, 200); // Á®çÈïøÂª∂Êó∂Áªô UI ÂèçÂ∫î
    }

    function downloadBlob(blob, name) {
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = name;
      a.click();
      setTimeout(() => URL.revokeObjectURL(a.href), 1000);
    }

    function drawLumetric() {
      const ctx = els.waveform;
      const w = ctx.canvas.width;
      const h = ctx.canvas.height;
      ctx.fillStyle = 'rgba(0,0,0,1)'; 
      ctx.fillRect(0, 0, w, h);
      
      const imgData = offCtx.getImageData(0, 0, state.planeW, state.planeH).data;
      ctx.fillStyle = state.isPainting ? '#FFD60A' : '#32D74B'; // ÁªòÂà∂Êó∂ÂèòËâ≤

      const step = Math.ceil(state.planeW / w);
      for (let x = 0; x < w; x++) {
        const srcX = Math.floor(x * (state.planeW / w));
        for(let y=0; y<state.planeH; y+=20) {
            const idx = (y * state.planeW + srcX) * 4;
            if(idx < imgData.length) {
                const r = imgData[idx], g = imgData[idx+1], b = imgData[idx+2];
                const luma = (0.299*r + 0.587*g + 0.114*b) / 255;
                const py = h - (luma * h);
                ctx.fillRect(x, py, 1, 1.5);
            }
        }
      }
    }

    // --- UI ---
    function setupUI() {
      const toggleMenu = () => els.sheet.classList.toggle('collapsed');
      els.sheetToggle.addEventListener('click', (e) => { e.stopPropagation(); toggleMenu(); });
      renderer.domElement.addEventListener('click', () => {
        if (!els.sheet.classList.contains('collapsed')) els.sheet.classList.add('collapsed');
      });

      // Camera Btn
      els.camFab.addEventListener('click', () => { showToast("Resetting..."); startCamera(); });

      // Clear Btn
      els.clearFab.addEventListener('click', clearPaint);

      // Paint Btn (Toggle)
      els.paintFab.addEventListener('click', () => {
        state.isPainting = !state.isPainting;
        if (state.isPainting) {
          els.paintFab.classList.add('active-paint');
          els.paintFab.innerHTML = "üõë Stop";
          els.statusDot.classList.add('painting');
          els.sourceText.textContent = "Scanning...";
        } else {
          els.paintFab.classList.remove('active-paint');
          els.paintFab.innerHTML = "üñåÔ∏è Paint";
          els.statusDot.classList.remove('painting');
          els.sourceText.textContent = "Ready";
        }
      });

      els.modeBtn.addEventListener('click', () => {
        state.mode = state.mode === 'mesh' ? 'points' : 'mesh';
        els.modeBtn.textContent = state.mode === 'mesh' ? 'View Points' : 'View Mesh';
        els.modeBtn.classList.toggle('primary'); 
        updateVisibility();
      });

      els.switchBtn.addEventListener('click', () => {
        if (state.source === 'camera') {
          if (state.imageLoaded) {
            state.source = 'image';
            state.isPainting = false; // ÂàáÊç¢Ê®°ÂºèÂÅúÊ≠¢ÁªòÂà∂
            updateUIMode();
            applyImageResolution();
          } else {
            els.imgInput.click();
          }
        } else {
          startCamera();
        }
      });

      els.imgInput.addEventListener('change', (e) => {
        if(e.target.files && e.target.files[0]) {
          const url = URL.createObjectURL(e.target.files[0]);
          imgEl.src = url; 
        }
      });

      els.sliders.ext.addEventListener('input', (e) => {
        state.extrusion = parseFloat(e.target.value);
        els.vals.ext.textContent = state.extrusion;
      });
      
      // Speed Slider
      els.sliders.speed.addEventListener('input', (e) => {
        state.scanSpeed = parseInt(e.target.value);
        els.vals.speed.textContent = state.scanSpeed;
      });

      els.sliders.size.addEventListener('input', (e) => {
        state.pointSize = parseFloat(e.target.value);
        els.vals.size.textContent = state.pointSize.toFixed(1);
        particlesMat.size = state.pointSize;
      });

      els.sliders.res.addEventListener('input', (e) => {
        state.resScale = parseInt(e.target.value);
        els.vals.res.textContent = state.resScale + "x";
        clearTimeout(window.resTimer);
        window.resTimer = setTimeout(applyImageResolution, 200);
      });

      els.exportBtn.addEventListener('click', performExport);
    }

    function updateUIMode() {
      const isImg = state.source === 'image';
      els.sourceText.textContent = isImg ? "Image Mode" : "Ready";
      els.resContainer.style.opacity = isImg ? '1' : '0.5';
      els.resContainer.style.pointerEvents = isImg ? 'auto' : 'none';
      els.statusDot.className = 'dot'; 
      // ÁªòÂà∂ÂäüËÉΩÂú®ÂõæÁâáÊ®°Âºè‰∏ã‰πüÂèØ‰ª•Áî®Ôºå‰ΩÜ‰∏ªË¶ÅÊòØ‰∏∫ÊëÑÂÉèÂ§¥ËÆæËÆ°ÁöÑ
    }

    function updateStatus(active, text) {
      els.statusDot.className = active ? 'dot' : 'dot inactive';
      els.sourceText.textContent = text;
    }

    function showToast(msg) {
      els.toast.textContent = msg;
      els.toast.style.opacity = 1;
      setTimeout(() => els.toast.style.opacity = 0, 3000);
    }
  </script>
</body>
</html>
